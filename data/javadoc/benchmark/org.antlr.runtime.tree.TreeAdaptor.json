{
    "class": "TreeAdaptor",
    "category": "Interface",
    "methods": {
        "void addChild(Object t, Object child)": "Add a child to the tree t.",
        "Object becomeRoot(Object newRoot, Object oldRoot)": "If oldRoot is a nil root, just copy or move the children to newRoot.",
        "Object becomeRoot(Token newRoot, Object oldRoot)": "Create a node for newRoot make it the root of oldRoot.",
        "Object create(int tokenType, String text)": "Create a new node derived from a token, with a new token type.",
        "Object create(int tokenType, Token fromToken)": "Create a new node derived from a token, with a new token type.",
        "Object create(int tokenType, Token fromToken, String text)": "Same as create(tokenType, fromToken) except set the text too.",
        "Object create(Token payload)": "Create a tree node from Token object; for CommonTree type trees, then the token just becomes the payload.",
        "Object deleteChild(Object t, int i)": "Remove ith child and shift children down from right.",
        "Object dupNode(Object treeNode)": "Duplicate a single tree node.",
        "Object dupTree(Object tree)": "Duplicate tree recursively, using dupNode() for each node",
        "Object errorNode(TokenStream input, Token start, Token stop, RecognitionException e)": "Return a tree node representing an error.",
        "Object getChild(Object t, int i)": "Get a child 0..n-1 node",
        "int getChildCount(Object t)": "How many children? If 0, then this is a leaf node",
        "int getChildIndex(Object t)": "What index is this node in the child list? Range: 0..n-1 If your node type doesn't handle this, it's ok but the tree rewrites in tree parsers need this functionality.",
        "Object getParent(Object t)": "Who is the parent node of this node; if null, implies node is root.",
        "String getText(Object t)": "",
        "Token getToken(Object t)": "Return the token object from which this node was created.",
        "int getTokenStartIndex(Object t)": "Get the token start index for this subtree; return -1 if no such index",
        "int getTokenStopIndex(Object t)": "Get the token stop index for this subtree; return -1 if no such index",
        "int getType(Object t)": "For tree parsing, I need to know the token type of a node",
        "int getUniqueID(Object node)": "For identifying trees.",
        "boolean isNil(Object tree)": "Is tree considered a nil node used to make lists of child nodes?",
        "Object nil()": "Return a nil node (an empty but non-null node) that can hold a list of element as the children.",
        "void replaceChildren(Object parent, int startChildIndex, int stopChildIndex, Object t)": "Replace from start to stop child index of parent with t, which might be a list.",
        "Object rulePostProcessing(Object root)": "Given the root of the subtree created for this rule, post process it to do any simplifications or whatever you want.",
        "void setChild(Object t, int i, Object child)": "Set ith child (0..n-1) to t; t must be non-null and non-nil node",
        "void setChildIndex(Object t, int index)": "",
        "void setParent(Object t, Object parent)": "",
        "void setText(Object t, String text)": "Node constructors can set the text of a node",
        "void setTokenBoundaries(Object t, Token startToken, Token stopToken)": "Where are the bounds in the input token stream for this node and all children? Each rule that creates AST nodes will call this method right before returning.",
        "void setType(Object t, int type)": "Node constructors can set the type of a node"
    },
    "super class": []
}